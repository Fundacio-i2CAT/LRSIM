import math
import os
import unittest

from src import logger
from src.distance_tools import geodetic2cartesian
from src.dynamic_state.generate_dynamic_state import generate_dynamic_state
from src.tles.generate_tles_from_scratch import generate_tles_from_scratch_with_sgp
from src.tles.read_tles import (
    read_tles,
)
from src.topology.satellite.satellite import Satellite
from src.topology.topology import (
    ConstellationData,
    GroundStation,
)

log = logger.get_logger(__name__)


def run_ether_demo():
    """
    Integration test for a single orbit with TLEs generated by SGP method.
    Checks state every 12 minutes for 24 hours.
    """
    constellation_name = "SingleOrbitTest"
    num_orbits = 1
    num_sats_per_orbit = 8
    phase_diff = False
    inclination_degree = 51.9
    eccentricity = 0.0000001
    arg_of_perigee_degree = 0.0
    mean_motion_rev_per_day = 14.80
    tle_output_filename = "tles_single_orbit_sgp.txt.tmp"

    generate_tles_from_scratch_with_sgp(
        tle_output_filename,
        constellation_name,
        num_orbits,
        num_sats_per_orbit,
        phase_diff,
        inclination_degree,
        eccentricity,
        arg_of_perigee_degree,
        mean_motion_rev_per_day,
    )
    parsed_tles_data = read_tles(tle_output_filename)
    sim_satellites = []
    for i, ephem_obj in enumerate(parsed_tles_data["satellites"]):
        sim_satellites.append(
            Satellite(id=i, ephem_obj_manual=ephem_obj, ephem_obj_direct=ephem_obj)
        )
    output_dir = None
    sim_epoch = parsed_tles_data["epoch"]
    dynamic_state_algorithm = "algorithm_free_one_only_over_isls"
    altitude_m = 630000
    earth_radius = 6378135.0
    satellite_cone_radius_m = altitude_m / math.tan(math.radians(30.0))
    max_gsl_length_m = math.sqrt(math.pow(satellite_cone_radius_m, 2) + math.pow(altitude_m, 2))
    max_isl_length_m = 2 * math.sqrt(
        math.pow(earth_radius + altitude_m, 2) - math.pow(earth_radius + 80000, 2)
    )
    gs_start_id = num_sats_per_orbit
    GS_LONDON_ID = gs_start_id
    GS_PERTH_ID = gs_start_id + 1
    london_lat, london_lon, london_elv = 51.5074, -0.1278, 30.0
    london_x, london_y, london_z = geodetic2cartesian(london_lat, london_lon, london_elv)
    perth_lat, perth_lon, perth_elv = -31.9505, 115.8605, 30.0
    perth_x, perth_y, perth_z = geodetic2cartesian(perth_lat, perth_lon, perth_elv)
    ground_stations = [
        GroundStation(
            gid=GS_LONDON_ID,
            name="London",
            latitude_degrees_str=str(london_lat),
            longitude_degrees_str=str(london_lon),
            elevation_m_float=london_elv,
            cartesian_x=london_x,
            cartesian_y=london_y,
            cartesian_z=london_z,
        ),
        GroundStation(
            gid=GS_PERTH_ID,
            name="Perth",
            latitude_degrees_str=str(perth_lat),
            longitude_degrees_str=str(perth_lon),
            elevation_m_float=perth_elv,
            cartesian_x=perth_x,
            cartesian_y=perth_y,
            cartesian_z=perth_z,
        ),
    ]
    constellation_data = ConstellationData(
        orbits=parsed_tles_data["n_orbits"],
        sats_per_orbit=parsed_tles_data["n_sats_per_orbit"],
        epoch="2000/1/1",
        max_gsl_length_m=max_gsl_length_m,
        max_isl_length_m=max_isl_length_m,
        satellites=sim_satellites,
    )
    undirected_isls = []
    if num_sats_per_orbit > 1:
        for i in range(num_sats_per_orbit - 1):
            undirected_isls.append((i, i + 1))
    gsl_node_ids = list(range(num_sats_per_orbit)) + [GS_LONDON_ID, GS_PERTH_ID]
    list_gsl_interfaces_info = [
        {"id": node_id, "number_of_interfaces": 1, "aggregate_max_bandwidth": 1.0}
        for node_id in gsl_node_ids
    ]
    # 24 hours in nanoseconds, 12 minutes per step
    simulation_end_time_ns = 24 * 60 * 60 * 1_000_000_000  # 24 hours in ns
    time_step_ns = 12 * 60 * 1_000_000_000  # 12 minutes in ns
    offset_ns = 0    
    all_states = generate_dynamic_state(
        output_dynamic_state_dir=output_dir,
        epoch=sim_epoch,
        simulation_end_time_ns=simulation_end_time_ns,
        time_step_ns=time_step_ns,
        offset_ns=offset_ns,
        constellation_data=constellation_data,
        ground_stations=ground_stations,
        undirected_isls=undirected_isls,
        list_gsl_interfaces_info=list_gsl_interfaces_info,
        dynamic_state_algorithm=dynamic_state_algorithm,
    )    
    for idx, state in enumerate(all_states):
        log.info(f"Generated fstate at step {idx}: {state['fstate']}")

if __name__ == "__main__":   
    run_ether_demo()
