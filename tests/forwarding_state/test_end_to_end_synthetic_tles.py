import math
import os
import unittest

from src import logger
from src.distance_tools import geodetic2cartesian
from src.network_state.generate_network_state import generate_dynamic_state_at
from src.tles.generate_tles_from_scratch import generate_tles_from_scratch_with_sgp
from src.tles.read_tles import read_tles  # You might need to ensure this is accessible
from src.topology.satellite.satellite import Satellite
from src.topology.topology import (
    ConstellationData,
    GroundStation,
)

log = logger.get_logger(__name__)


class TestEndToEndWithSyntheticTLEs(unittest.TestCase):

    def test_single_orbit_sgp_generated_path(self):
        """
        Integration test for a single orbit with TLEs generated by SGP method.
        Checks state at t=0.
        """
        constellation_name = "SingleOrbitTest"
        num_orbits = 1
        num_sats_per_orbit = 8
        phase_diff = False
        inclination_degree = 51.9
        eccentricity = 0.0000001
        arg_of_perigee_degree = 0.0
        mean_motion_rev_per_day = 14.80
        tle_output_filename = "tles_single_orbit_sgp.txt.tmp"

        generate_tles_from_scratch_with_sgp(
            tle_output_filename,
            constellation_name,
            num_orbits,
            num_sats_per_orbit,
            phase_diff,
            inclination_degree,
            eccentricity,
            arg_of_perigee_degree,
            mean_motion_rev_per_day,
        )
        parsed_tles_data = read_tles(tle_output_filename)
        sim_satellites = []
        for i, ephem_obj in enumerate(parsed_tles_data["satellites"]):
            sim_satellites.append(
                Satellite(id=i, ephem_obj_manual=ephem_obj, ephem_obj_direct=ephem_obj)
            )

        self.assertEqual(
            len(sim_satellites), num_sats_per_orbit, "Incorrect number of satellites processed."
        )
        output_dir = None
        # The epoch from TLE generation is fixed to 2000-01-01 00:00:00 by generate_tles_from_scratch
        # The read_tles function correctly parses this.
        sim_epoch = parsed_tles_data["epoch"]  # Use the epoch read from the TLE file
        dynamic_state_algorithm = "algorithm_free_one_only_over_isls"
        altitude_m = 630000
        earth_radius = 6378135.0
        satellite_cone_radius_m = altitude_m / math.tan(math.radians(30.0))
        max_gsl_length_m = math.sqrt(math.pow(satellite_cone_radius_m, 2) + math.pow(altitude_m, 2))
        max_isl_length_m = 2 * math.sqrt(
            math.pow(earth_radius + altitude_m, 2) - math.pow(earth_radius + 80000, 2)
        )
        gs_start_id = num_sats_per_orbit
        GS_LONDON_ID = gs_start_id
        GS_PERTH_ID = gs_start_id + 1

        # Coordinates for London (approx. Charing Cross)
        london_lat, london_lon, london_elv = 51.5074, -0.1278, 30.0  # Elevation in meters
        london_x, london_y, london_z = geodetic2cartesian(london_lat, london_lon, london_elv)

        # Coordinates for Perth
        perth_lat, perth_lon, perth_elv = -31.9505, 115.8605, 30.0  # Elevation in meters
        perth_x, perth_y, perth_z = geodetic2cartesian(perth_lat, perth_lon, perth_elv)

        ground_stations = [
            GroundStation(
                gid=GS_LONDON_ID,
                name="London",
                latitude_degrees_str=str(london_lat),
                longitude_degrees_str=str(london_lon),
                elevation_m_float=london_elv,
                cartesian_x=london_x,
                cartesian_y=london_y,
                cartesian_z=london_z,
            ),
            GroundStation(
                gid=GS_PERTH_ID,
                name="Perth",
                latitude_degrees_str=str(perth_lat),
                longitude_degrees_str=str(perth_lon),
                elevation_m_float=perth_elv,
                cartesian_x=perth_x,
                cartesian_y=perth_y,
                cartesian_z=perth_z,
            ),
        ]
        constellation_data = ConstellationData(
            orbits=parsed_tles_data["n_orbits"],  # This will be num_orbits_gen (e.g., 1)
            sats_per_orbit=parsed_tles_data[
                "n_sats_per_orbit"
            ],  # This will be num_sats_per_orbit_gen
            epoch="2000/1/1",
            max_gsl_length_m=max_gsl_length_m,
            max_isl_length_m=max_isl_length_m,
            satellites=sim_satellites,  # The list of Satellite objects
        )

        # ISLs for the single orbit
        undirected_isls = []
        if num_sats_per_orbit > 1:
            for i in range(num_sats_per_orbit - 1):
                undirected_isls.append((i, i + 1))  # Sat IDs are 0 to N-1
            # if num_sats_per_orbit_gen > 2: # Optional: close the ring
            #     undirected_isls.append((num_sats_per_orbit_gen - 1, 0))

        gsl_node_ids = list(range(num_sats_per_orbit)) + [
            GS_LONDON_ID,
            GS_PERTH_ID,
        ]
        list_gsl_interfaces_info = [
            {"id": node_id, "number_of_interfaces": 1, "aggregate_max_bandwidth": 1.0}
            for node_id in gsl_node_ids
        ]
        print(f"\n--- Checking Full State for Single Orbit at t=0 ns ({constellation_name}) ---")
        result_state_t0, topology_t0 = generate_dynamic_state_at(
            output_dynamic_state_dir=output_dir,
            epoch=sim_epoch,  # Use the astropy.Time object here, as generate_dynamic_state_at likely needs it
            time_since_epoch_ns=0,
            constellation_data=constellation_data,
            ground_stations=ground_stations,
            undirected_isls=undirected_isls,
            list_gsl_interfaces_info=list_gsl_interfaces_info,
            dynamic_state_algorithm=dynamic_state_algorithm,
            prev_output=None,
            prev_topology=None,
        )
        self.assertIsNotNone(
            result_state_t0, "generate_dynamic_state_at returned None at t=0 for single orbit"
        )
        self.assertIn("fstate", result_state_t0)
        fstate_t0 = result_state_t0["fstate"]
        print("Generated fstate at t=0 for single orbit:")
        log.info(fstate_t0)

        # --- Define Expected State for t=0 ---
        # This section requires careful determination based on the new GS locations
        # and satellite positions at t=0.
        # Example structure (actual values will depend on visibility):
        # expected_fstate_t0_single_orbit = {
        #    (GS_LONDON_ID, SAT_ID_VISIBLE_TO_LONDON): (if_gs_london, if_sat_london, 0),
        #    (SAT_ID_1, SAT_ID_2): (if_sat1_isl, if_sat2_isl, 0), # For an ISL
        #    (SAT_ID_VISIBLE_TO_CARDIFF, GS_CARDIFF_ID): (if_sat_cardiff, if_gs_cardiff, 0)
        # }
        # You will need to replace this with actual expected values after observing the output.
        # self.assertDictEqual(fstate_t0, expected_fstate_t0_single_orbit, "fstate mismatch for single orbit at t=0")

        # For now, a very basic check:
        self.assertTrue(isinstance(fstate_t0, dict), "fstate_t0 is not a dictionary.")
        # Add more specific assertions once you observe the output and determine expected behavior.
        # For example, check if any satellite is connected to London if expected:
        # london_connected_to_any_sat = any(GS_LONDON_ID == key_tuple[0] or GS_LONDON_ID == key_tuple[1] for key_tuple in fstate_t0.keys())
        # self.assertTrue(london_connected_to_any_sat, "London is not connected to any satellite at t=0 as per fstate")

        # --- Cleanup ---
        # if os.path.exists(tle_output_filename):
        #     os.remove(tle_output_filename)
