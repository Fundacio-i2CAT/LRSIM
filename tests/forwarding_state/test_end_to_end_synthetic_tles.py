import math
import os
import unittest
from src.tles.generate_tles_from_scratch import generate_tles_from_scratch_with_sgp
from src.tles.read_tles import read_tles  # You might need to ensure this is accessible

from src.tles.read_tles import (
    read_tles,
)

from src.dynamic_state.generate_dynamic_state import generate_dynamic_state_at
from src.dynamic_state.topology import (
    ConstellationData,
    GroundStation,
    Satellite,
)
from src.distance_tools import geodetic2cartesian

from src import logger

log = logger.get_logger(__name__)


class TestEndToEndWithSyntheticTLEs(unittest.TestCase):

    def test_single_orbit_sgp_generated_path(self):
        """
        Integration test for a single orbit with TLEs generated by SGP method.
        Checks state at t=0.
        """
        constellation_name = "SingleOrbitTest"
        num_orbits = 1
        num_sats_per_orbit = 10
        phase_diff = False
        inclination_degree = 51.9
        eccentricity = 0.0000001
        arg_of_perigee_degree = 0.0
        mean_motion_rev_per_day = 14.80
        tle_output_filename = "tles_single_orbit_sgp.txt.tmp"

        generate_tles_from_scratch_with_sgp(
            tle_output_filename,
            constellation_name,
            num_orbits,
            num_sats_per_orbit,
            phase_diff,
            inclination_degree,
            eccentricity,
            arg_of_perigee_degree,
            mean_motion_rev_per_day,
        )
        parsed_tles_data = read_tles(tle_output_filename)
        sim_satellites = []
        for i, ephem_obj in enumerate(parsed_tles_data["satellites"]):
            sim_satellites.append(
                Satellite(id=i, ephem_obj_manual=ephem_obj, ephem_obj_direct=ephem_obj)
            )

        self.assertEqual(
            len(sim_satellites), num_sats_per_orbit, "Incorrect number of satellites processed."
        )
        output_dir = None
        # The epoch from TLE generation is fixed to 2000-01-01 00:00:00 by generate_tles_from_scratch
        # The read_tles function correctly parses this.
        sim_epoch = parsed_tles_data["epoch"]  # Use the epoch read from the TLE file
        dynamic_state_algorithm = "algorithm_free_one_only_over_isls"
        altitude_m = 630000
        earth_radius = 6378135.0
        satellite_cone_radius_m = altitude_m / math.tan(math.radians(30.0))
        max_gsl_length_m = math.sqrt(math.pow(satellite_cone_radius_m, 2) + math.pow(altitude_m, 2))
        max_isl_length_m = 2 * math.sqrt(
            math.pow(earth_radius + altitude_m, 2) - math.pow(earth_radius + 80000, 2)
        )
        gs_start_id = num_sats_per_orbit
        GS_MANILA_ID = gs_start_id
        GS_DALIAN_ID = gs_start_id + 1
        manila_lat, manila_lon, manila_elv = 14.6042, 120.9822, 0.0
        manila_x, manila_y, manila_z = geodetic2cartesian(manila_lat, manila_lon, manila_elv)
        dalian_lat, dalian_lon, dalian_elv = 38.913811, 121.602322, 0.0
        dalian_x, dalian_y, dalian_z = geodetic2cartesian(dalian_lat, dalian_lon, dalian_elv)
        ground_stations = [
            GroundStation(
                gid=GS_MANILA_ID,
                name="Manila",
                latitude_degrees_str=str(manila_lat),
                longitude_degrees_str=str(manila_lon),
                elevation_m_float=manila_elv,
                cartesian_x=manila_x,
                cartesian_y=manila_y,
                cartesian_z=manila_z,
            ),
            GroundStation(
                gid=GS_DALIAN_ID,
                name="Dalian",
                latitude_degrees_str=str(dalian_lat),
                longitude_degrees_str=str(dalian_lon),
                elevation_m_float=dalian_elv,
                cartesian_x=dalian_x,
                cartesian_y=dalian_y,
                cartesian_z=dalian_z,
            ),
        ]
        constellation_data = ConstellationData(
            orbits=parsed_tles_data["n_orbits"],  # This will be num_orbits_gen (e.g., 1)
            sats_per_orbit=parsed_tles_data[
                "n_sats_per_orbit"
            ],  # This will be num_sats_per_orbit_gen
            epoch="2000/1/1",
            max_gsl_length_m=max_gsl_length_m,
            max_isl_length_m=max_isl_length_m,
            satellites=sim_satellites,  # The list of Satellite objects
        )

        # ISLs for the single orbit
        undirected_isls = []
        if num_sats_per_orbit > 1:
            for i in range(num_sats_per_orbit - 1):
                undirected_isls.append((i, i + 1))  # Sat IDs are 0 to N-1
            # if num_sats_per_orbit_gen > 2: # Optional: close the ring
            #     undirected_isls.append((num_sats_per_orbit_gen - 1, 0))
        gsl_node_ids = list(range(num_sats_per_orbit)) + [GS_MANILA_ID, GS_DALIAN_ID]
        list_gsl_interfaces_info = [
            {"id": node_id, "number_of_interfaces": 1, "aggregate_max_bandwidth": 1.0}
            for node_id in gsl_node_ids
        ]
        print(f"\n--- Checking Full State for Single Orbit at t=0 ns ({constellation_name}) ---")
        result_state_t0, topology_t0 = generate_dynamic_state_at(
            output_dynamic_state_dir=output_dir,
            epoch=sim_epoch,  # Use the astropy.Time object here, as generate_dynamic_state_at likely needs it
            time_since_epoch_ns=0,
            constellation_data=constellation_data,
            ground_stations=ground_stations,
            undirected_isls=undirected_isls,
            list_gsl_interfaces_info=list_gsl_interfaces_info,
            dynamic_state_algorithm=dynamic_state_algorithm,
            prev_output=None,
            prev_topology=None,
        )
        self.assertIsNotNone(
            result_state_t0, "generate_dynamic_state_at returned None at t=0 for single orbit"
        )
        self.assertIn("fstate", result_state_t0)
        fstate_t0 = result_state_t0["fstate"]
        print("Generated fstate at t=0 for single orbit:")
        log.info(fstate_t0)

        # --- Define Expected State for t=0 ---
        # This section requires careful determination.
        # For num_sats_per_orbit_gen = 2 (Satellites 0, 1) and GS_MANILA_ID=2, GS_DALIAN_ID=3
        # An example expectation IF Manila can see Sat 0, Sat 0 can ISL to Sat 1, Sat 1 can see Dalian.
        # expected_fstate_t0_single_orbit = {
        #    (2, 3): (0, 0, 0),  # Manila (2) -> Sat 0 (IF 0 on Manila, IF 0 on Sat 0 for GSL)
        #    (0, 3): (1, 0, 0),  # Sat 0 -> Sat 1 (IF 0 on Sat 0 for ISL, IF 0 on Sat 1 for ISL)
        #    (1, 3): (3, 0, 0)   # Sat 1 -> Dalian (3) (IF 0 on Sat 1 for GSL, IF 0 on Dalian for GSL)
        # }
        # You will need to replace this with actual expected values after observing the output.
        # self.assertDictEqual(fstate_t0, expected_fstate_t0_single_orbit, "fstate mismatch for single orbit at t=0")

        # For now, a very basic check:
        self.assertTrue(isinstance(fstate_t0, dict), "fstate_t0 is not a dictionary.")
        # Add more specific assertions once you observe the output and determine expected behavior.
        # For example, check if any satellite is connected to Manila if expected:
        # manila_connected_to_any_sat = any(fstate_t0.get((GS_MANILA_ID, sat.id)) for sat in sim_satellites)
        # self.assertTrue(manila_connected_to_any_sat, "Manila is not connected to any satellite at t=0")

        # --- Cleanup ---
        # if os.path.exists(tle_output_filename):
        #     os.remove(tle_output_filename)
